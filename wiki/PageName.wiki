#summary One-sentence summary of this page.

= Introduction =

Add your content here.


= Details =

Add your content here.  Format your content with:
  * Text in *bold* or _italic_
  * Headings, paragraphs, and lists
  * Automatic links to other wiki pages

{{{#!c

/**
 * @author firsttimelove@gmail.com
 * connected_component_example.c : sample code for detecting connected
 * component.  
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MATRIX_ROW 10 
#define MATRIX_COL 10 

/**
 * sample matrix. expected group count = 10,20,16,3,2,1
 */
unsigned char sample_matrix[ MATRIX_ROW * MATRIX_COL ] = {
    0,0,1,0,1,1,1,1,0,1,
    0,0,1,0,1,1,1,1,0,1,
    0,0,1,0,1,1,1,1,0,1,
    0,0,1,0,1,1,1,1,0,0,
    0,0,1,0,1,1,1,1,0,0,
    0,0,1,0,0,0,0,0,0,1,
    0,0,1,0,1,1,1,1,0,1,
    0,0,1,0,1,1,1,1,0,0,
    0,0,1,0,1,1,1,1,0,1,
    0,0,1,0,1,1,1,1,0,0
}; 


/**
 * if defined below, regard diagonal position as connected. comment below if
 * you want to regard diagonal as not connected.
 */
#define CONNECTED_COMPONENT_WITH_DIAGONAL


/**
 * search directions(with/without diagonal directions)
 */
int blockAround[8][2] = { {-1,-1}, {0,-1}, {1,-1}, {-1,0}, {1,0}, {-1,1}, {0,1}, {1,1} }; 
int blockAroundWithoutDiagonal[4][2] = { {-1,0}, {1,0}, {0,-1}, {0,1} };


/**
 * for debug : print matrix to console.
 * @param matrix matrix array
 * @param title                         this string shows up before matrix be printed.
 *
 * @return                              void.
 */
void dump_matrix(unsigned char* matrix, 
        char* title,
        unsigned int width,
        unsigned int height){
    int i,j;

    printf("[%s]\n", title);
    printf("--------------------------------------------------------------------------------------------------\n");
    printf("   ");
    for (i=0;i<width;i++) {
        printf("%2d ", i);
    }
    printf("\n");
    printf("--------------------------------------------------------------------------------------------------\n");
    for (i=0;i<height;i++) {
        printf("%2d|", i);
        for (j=0;j<width;j++){
            printf("%2x ", matrix[ i*width+ j ]);
        }
        printf("\n");
    } 
    printf("--------------------------------------------------------------------------------------------------\n\n");
}

/**
 * Linearly searches pArray with argument 'value', and return result.
 *
 * @param value         value to search
 * @param pArray        pointer to array
 * @param arraySize     szie of array 'pArray'
 *
 * @return              1 if found, else 0.
 */
int findInArrayUINT(unsigned int value, unsigned int *pArray, unsigned int arraySize) {
    int i;
    for (i=0;i<arraySize;i++){
        if (pArray[i] == value)
            return 1;
    }
    return 0;
}

/**
 * Check connected components.
 * 
 * @param matrix     matrix array with values( 0 - nothing, not 0 - spot existed.
 * @return           biggest group count. 
 */
int check_connected_component(unsigned char* matrix)
{

    unsigned int i,j;    
    unsigned int blkRow, blkCol;
    unsigned int tmpBlkRow, tmpBlkCol;
    unsigned int curBlkRow, curBlkCol; 
    unsigned int value;
    unsigned int tmpValue;

    /**
     * stacks for detect connected components.
     */
    unsigned int stackTemporary[ MATRIX_ROW*MATRIX_COL ];
    unsigned int stackTemporaryTop; 
    unsigned int stackFinal[ MATRIX_ROW*MATRIX_COL ];
    unsigned int stackFinalTop; 
    unsigned int stackGroup[ MATRIX_ROW*MATRIX_COL ]; 
    unsigned int stackGroupTop; 

    /**
     * block map used for detecting connected components.
     */
    unsigned char matrixGroup[ MATRIX_ROW*MATRIX_COL ]; 

    // initialize stack
    stackTemporaryTop = 0;
    stackFinalTop = 0;
    stackGroupTop = 0;

    // initialize matrixGroup 
    for (blkRow=0 ; blkRow < MATRIX_ROW ; blkRow++) {
        for (blkCol=0 ; blkCol < MATRIX_COL ; blkCol++) {
            matrixGroup[blkRow * MATRIX_COL + blkCol]=0;
        }
    }


    for (blkRow=0 ; blkRow < MATRIX_ROW ; blkRow++) {
        for (blkCol=0 ; blkCol < MATRIX_COL ; blkCol++) { 
            // init stackFinal.
            stackFinalTop = 0; 

            if (matrix[ blkRow * MATRIX_COL + blkCol]) {   // spot exists. 
                if (!matrixGroup[blkRow * MATRIX_COL + blkCol]) {    // not checked for other group yet.

                    // init stackTemporary, stackFinal;
                    stackTemporaryTop = 0;
                    stackFinalTop = 0; 


                    // push current block to stackTemporary
                    stackTemporary[stackTemporaryTop++] = ((blkRow << 16) | blkCol);

                    // loop until immediate stack not empty... 
                    while( stackTemporaryTop > 0 ) { 
                        // pop one from stackTemporary
                        value = stackTemporary[--stackTemporaryTop]; 

                        // extract position from value
                        tmpBlkRow = value >> 16; 
                        tmpBlkCol = value & 0x0000ffff;

                        // check surrounded blocks... 
#if defined(CONNECTED_COMPONENT_WITH_DIAGONAL)
                        for (i=0;i<8;i++) {
                            curBlkRow = tmpBlkRow + blockAround[i][0];
                            curBlkCol = tmpBlkCol + blockAround[i][1]; 
                            tmpValue = (curBlkRow << 16) | curBlkCol;
#else
                        for (i=0;i<4;i++) {
                            curBlkRow = tmpBlkRow + blockAroundWithoutDiagonal[i][0];
                            curBlkCol = tmpBlkCol + blockAroundWithoutDiagonal[i][1]; 
                            tmpValue = (curBlkRow << 16) | curBlkCol;
#endif

                            // check position : 
                            if (curBlkRow < 0 || curBlkCol < 0 || curBlkRow >= MATRIX_ROW || curBlkCol >= MATRIX_COL ) {
                                continue;
                            }

                            // if current position doesn't belong to any
                            // group and not in immediate stack, push it to
                            // temporary stack.
                            if (matrix[curBlkRow * MATRIX_COL + curBlkCol] &&                               // if point existed 
                                    !matrixGroup[curBlkRow * MATRIX_COL + curBlkCol] &&                     // if not grouped.
                                    !findInArrayUINT(tmpValue, stackTemporary, stackTemporaryTop) &&        // if not in stackTemporary.
                                    !findInArrayUINT(tmpValue, stackFinal, stackFinalTop)) {                // if not in stackFinal. 

                                // push to temporary stack. 

                                stackTemporary[stackTemporaryTop++] = ( (curBlkRow<<16) | curBlkCol ); 
                            }
                        } 

                        // push current block to stackFinal and set checked
                        stackFinal[stackFinalTop++] = value; 
                        matrixGroup[ tmpBlkRow * MATRIX_COL + tmpBlkCol ] = 1; 
                    } 

                    /**
                     * at this position, stackFinal[] has list of
                     * grouped spot. if you need this, simply copy
                     * stackFinal[] to other allocated memory
                     */ 
                    // push current group's number to stackGroup 
                    stackGroup[stackGroupTop++] = stackFinalTop; 

                    printf("group count %d\n", stackFinalTop);

                }// if (!matrixGroup[ blkRow * MATRIX_ROW + blkCol])  
            }// if (matrix[ blkRow * MATRIX_ROW + blkCol]) 
        }// for (blkCol=0 ; blkCol < MATRIX_COL ; blkCol++) {
    }// for (blkRow=0 ; blkRow < MATRIX_ROW ; blkRow++) {

    value=0;
    for (i=0;i<stackGroupTop;i++) {
        if (value < stackGroup[i]) {
            value = stackGroup[i];
        }
    } 


    return value;
} 


int main(int argc, char** argv) {
    dump_matrix(sample_matrix, "source", MATRIX_COL, MATRIX_ROW);
    return check_connected_component(sample_matrix); 
}






}}}